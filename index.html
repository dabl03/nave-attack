<!doctype html>
<html lang="es">
<head>
	<title>Nave-attack.</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<link rel="stylesheet" href="./juego de espacio.css"/>
	<style>
		.no-visible{
			display:none;
		}
		#click_game{
			width:100vw;
			height:100vh;
			position:fixed;
			z-index: 100;
			top:0;
			left:0;
		}
	</style>
</head>
<body onload="init();">
	<div id="click_game" onclick="F2(event);" onmousemove="move_nave(event);">
		<!--Debemos darle 100 segundo para que la funcion game termine su ciclo y se detenga.-->
		<button type="button" onclick="game_over=true;setTimeout(reiniciar,3000);alert('Se reiniciara en 3 segundo despues de que se cierre esta alerta');" id="reiniciar">REINICIAR</button>
	</div>
	<main id="contenedor">
		<div id="fondo">
			<!--generado por JavaScript-->
		</div>
		<div id="game">
			<!--Utilizo css para la nave porque no solo la nave será la que va a llevar la imagen.-->
			<div id="spacio_2"><!--Esto tendrá la imagen del espacio y será movida por CSS.--></div>
			<div id="nave" class="nave"></div>
			<!--Imagenes de la nave para simbolizar la vida del jugador en el lado derecho de la pantalla.-->
			<div id="vida">
				<!--generado por JavaScript-->
			</div>
			<div id="mina_voladora"></div>
			<div id="almacenDis"><!--para almacenar las balas generadas por JS.--></div>
			<!--<div id="almacenAtackE"></div>-->
			<div id="almacenEn"></div>
		</div>
	</main>
	<script src="./juego de espacio.js"></script>
	<script>
		"uses strict";
		/***
			- Crear un intervalo o una reques animation para mover el fondo y los personajes.
			- En el intervalo actual es el que usaremos para determinar todo.
			- También modificar el juego para que sea pantalla completa.
			- TODO HACER: Agregar más enemigos.
			- Úsalo para remover los monstros que pierde y busca una función para agregar objetos para el próximo nivel.
			- También modificar las clases para que tenga power attack que definirá el daño del imparto con el enemigo o el jugador.
			- También has comodines para: Darle más vidas al jugador, hacerlo invencible, aumentar el poder de ataque de los disparos.
			- También has un menú de inicio como tu otro juego, con el fondo de espacio.
			- También crea una imagen de perdió, otros enemigos y un rey.
		*/

		/*constantes\/*/
		const ta = [screen.width, screen.availHeight],
		MAX_Y = ta[1], /**/
		MAX_FONDOS = 3, /*Cantidad de imágenes del fondo.*/
		MAX_FONDO_Y = 200, /*Usamos porcentajes el fondo estará afuera si ==200%*/
		MAX_COLUNNA_ENEMIGOS = 3,
		HEIGHT_FONDO =100;//100%

		var nave = new naves(
		    new dim2d(0, 0, 30, 20), /*dim*/
		    4, /*life*/
	        get_element("nave"), /*Person*/
		    [4],
		    [],
	        undefined /*speed: No es necesario.*/
	    ),
		fondo = [4],//4 imagenes.
		enemigo = [],
		second_enemigo_abajo = 1000 * 40, /*Es para determinar el tiempo en que los enemigos bajaran hasta el jugador.*/
		es_momento_de_mover_enemigo = true /*Es para determinar si el enemigo se moverá o nó.*/;
		/*Creamos nuevos elementos para simbolizar la vida de los jugadores.*/
		var requesAnimation = null,
		move_enemy = true,
		game_over=false,
		interval_disp=false;
		function start_click(){
			if (interval_disp)
				end_click();
			interval_disp=setInterval(F2,200,0);
		}
		function end_click(){
			if (!interval_disp)
				return;
			clearInterval(interval_disp);
			interval_disp=false;
		}
		function init() {
		    requesAnimation = window.requestAnimationFrame || window.mozRequestAnimationFrame || webkitRequestAnimationFrame || window.msRequestAnimationFrame || setTimeout;
		    let click=get_element("click_game");
		    /*Eventos para dispositivos moviles.*/
		    click.addEventListener("touchmove", move_nave, false);
		    click.addEventListener("touchstart",start_click);
		    click.addEventListener("touchend",end_click);
		    /*Eventos pc*/
		    click.addEventListener("mousedown",start_click);
		    click.addEventListener("mouseup",end_click);
		    nave.dim.y = MAX_Y-(nave.dim.h * (Math.sqrt(ta[1]) / 4));
		    update(nave.person, nave.dim);
		    //Medidor vida
		    for (let l = 0, padre = get_element("vida"); l <= nave.life; l++) {
		    	let life=document.createElement("div");
		        nave.mostrar_life[l]=life;
		        life.setAttribute("id", "vida" + l);
		        life.setAttribute("class", "nave life");
		        padre.appendChild(life);
		    }
		    for (let f = 0, father = get_element("fondo"); f < MAX_FONDOS; f++) {
		        /*child hijo en ingres.*/
		        let img_f = create_element("div");
		        img_f.setAttribute("class", "space");
		        img_f.setAttribute("name", 'f' + f);
		        /*Le regalamos al hijo a su futuro padre y despues lo abandonamos.:)*/
		        father.appendChild(img_f);
		    }
		    for (let e = 0, padre = get_element("almacenEn"), x = 34, y = 5, w = x, h = 44, count = 0; count < MAX_COLUNNA_ENEMIGOS; e++, x += w + w) {
		        enemigo.splice(e, false, 
		        	new enemigos(/*Jeje Cuantos comentarios.*/
		                new dim2d(x, y, w, h), /*dim*/
		                4, /*life*/
		                "EN1",
		                new disparos(
		                    new dim2d(
		                        null, /*x:dim:disparo*/
		                        null, /*y:dim:disparo*/
		                        5, /*w:dim:disparo*/
		                        18 /*h:dim:disparo*/
		                    ), /*dim:disparo*/
		                    false, /*life:disparo*/ /*False por no existe esta bala.*/
		                    create_element("div") /*person:disparo*/
		                ), /*Disparo.*/
		                50, /*speed*/
		                0 /*Count.*/
		            )
		        );
		        enemigo[e].disparo.person.setAttribute("class", "disparo");
		        padre.appendChild(enemigo[e].person);
		        /*La posicion de los futuros personage la cambiamos si la posicion x se sale de la pantalla.*/
		        /*TODO REPARAR el fondo que no crea el efecto de un espacio en movimiento.
		        Tambien hacer que los disparos se muevan con un contador en vez de todo a la vez.*/
		        if (x > ta[0] - (w * Math.sqrt(ta[0]) / 6)) {
		            x = 0;
		            y += h + h;
		            count++;
		        }
		    }
		    reset();
		}
		function reset() { /*Inicializamos todas las letiables necesaria para el juego.*/
		    /*is_moment es para determinar si debemos llamar otra ves con setTimeOut a la funcion move_enemigo.*/
		    es_momento_de_mover_enemigo = true;
		    /*Inicializamos el fondo.*/
		    for (let f = 0, y = 0, fondos = document.getElementsByClassName("space"); f < fondos.length; f++, y = -100 * f /*-( HEIGHT_FONDO*f )*/) {
		        fondo[f] = new dim2d(undefined, y, undefined, HEIGHT_FONDO);
		        fondo[f].p = fondos[f];
		        fondo[f].p.style.top = y + "%";
		    }
		    game_over=false;
		    move_enemy = true;
		    requesAnimation(game);
		}
		function move_nave(e){
			e.preventDefault();
			if(e.changedTouches){
				let t=e.changedTouches;
				let time=0;
				nave.move_x(t[t.length-1].pageX)
				nave.move_y(t[t.length-1].pageY);
				return;
			}
			nave.move_x( e.clientX );
			nave.move_y(e.clientY);
		}
		/*onclick: Creamos una nueva bala.*/
		function F2(event) {
		    let count = nave.disparo.length; /*Solo comodidad.*/
		    nave.disparo.splice(
		        count, /*Indice para agregar.*/
		        false, /*Is deleted. No queremos eliminar un objeto lo que queremos es agregarlo*/
		        new disparos(/*value*/
		            new dim2d(
		                nave.dim.x, /*x: es nulo porque despues le asignaremos valor. Si quieres cambias el valor nulo por los valores correspondiente: mouse_x[0], nave.dim.y . No tendrá efecto al menos que elimines la funcion move_all que será usada mas adelante en el codigo.*/
		                nave.dim.y, /*y: es nulo por la misma razon que x.*/
		                5, /*w*/
		                20 /*h*/
		            ),
		            undefined, /*life: No la nesecitamos si podemos eliminar el arrays.*/
		            create_element("div"), /*person.*/
		            3.1415926535897932384626433832795 /*speed: Math.PI*/
		        )
		    );
		    get_element("almacenDis").appendChild(nave.disparo[count].person);
		    nave.disparo[count].person.setAttribute("class", "disparo"); /*Le agregamos el estilo.*/
		    nave.disparo[count].person.style.display = "block";
		    update(nave.disparo[count].person, nave.disparo[count].dim);
		}
		function ganar() {
		    if (confirm("FELICIDADES ME HAS GANADO QUIERES VOLVER A JUGAR...")) {
		    	game_over=false;
		        reiniciar();
		        return true;
		    } else {
		    	game_over=true;
		        alert("GRACIAS POR JUGAR");
		        return false;
		    }
		}
		
		function move_all() { /*Este es el primer interval: set[0]=setInterval( move_all,100 );*/
		    /*Movemos el fondo.*/
		    for (let f = 0; f < fondo.length; f++) {
		        fondo[f].y += 2;
		        /*Ponemos el fondo detras del anterior cuando llege al punto para hacer el efecto de un espacio continuo.*/
		        if (fondo[f].y > MAX_FONDO_Y) {
		            fondo[f].y = -100; /*( fondo[f].h );*/
		        }
		        fondo[f].p.style.top = fondo[f].y + "%";
		    }
		    if (es_momento_de_mover_enemigo) {
		        setTimeout(mover_enemigo, 500);
		        es_momento_de_mover_enemigo = false;
		    }
		    for (let d = 0; d < nave.disparo.length; d++) {
		        if (nave.disparo[d].dim.y > -50) {
		            nave.disparo[d].move_menos_y(nave.disparo[d].speed);
		        }
		    }
		}
		function mover_enemigo() {
		    for (let e = 0; e < enemigo.length; e++) {
		        let x = enemigo[e].dim.x;
		        let y = enemigo[e].dim.y;
		        let speed = enemigo[e].speed;
		        switch (enemigo[e].count) {
		        case 1:
		            enemigo[e].move_all(x + speed, y); /*Recuerda hacer esta funcion.*/
		            break;
		        case 2:
		            enemigo[e].move_all(x, y + speed); /*Recuerda hacer esta funcion.*/
		            break;
		        case 3:
		            enemigo[e].move_all(x - speed, y); /*Recuerda hacer esta funcion.*/
		            break;
		        case 4:
		            enemigo[e].move_all(x, y - speed);
		            enemigo[e].count = 0;
		            break;
		        }
		        enemigo[e].count++;
		    }
		    es_momento_de_mover_enemigo = true;
		}
		function move_enemigo_abajo() {
		    if (game_over)
		        return;
		    for (let e = 0; e < enemigo.length; e++) {
		        enemigo[e].move_all(enemigo[e].dim.x, enemigo[e].dim.y + enemigo[e].speed);
		    }
		    move_enemy = true;
		}
		function CO() { /*Este es el segundo interval: set[1]=setInterval( CO );*/
		    /*Verificamos si un disparo enemigo le dio a la nave.*/
		    for (let d = 0; d < nave.disparo.length; d++) {
		        let dim_n = nave.disparo[d].dim;
		        for (let e = 0; e < enemigo.length; e++) {
		            let dim_e = enemigo[e].dim;
		            /*La incleible formula de distancia. Te retorna la distancia de un objecto permitiendo solo hacer pocos calculos para ver si la bala colocionó con el personaje.*/
		            if (dim_n.dist(dim_e) < dim_n.w + dim_e.w && dim_n.dist(dim_e) < dim_n.h + dim_e.h) {
		                get_element("almacenDis").removeChild(nave.disparo[d].person);
		                nave.disparo.splice(d, true);
		                if (enemigo[e].life) {
		                    enemigo[e].imparto_recuperate();
		                    /*Dejamos que el enemigo se vea atacado por unos 200ms*/
		                    setTimeout(function (e) {
		                        /*Cuando el jugador dispara mucho disparo por segundo puede que esto se ejecute en el mismo momento que esta posición fué liberada de la memotia por lo tanto lee un arrays que ya no existe y por eso que verifico si la variable está definida o nó, solo para evitar errores en tiempo de ejecución.*/
		                        if (enemigo[e] != undefined) {
		                            enemigo[e].imparto_recuperate(false);
		                        }
		                    }, 200, e);
		                } else {
		                    let padre = get_element("almacenEn");
		                    enemigo[e].person.removeChild(enemigo[e].disparo.person);
		                    padre.removeChild(enemigo[e].person);
		                    /*Eliminamos la posicion e.*/
		                    enemigo.splice(e, true);
		                }
		                break;
		            }
		        }
		    } /*peder enemigo*/
		    for (let e = 0, dim = nave.dim; e < enemigo.length; e++) {
		        let disparo_e = enemigo[e].disparo;
		        let dim_e = disparo_e.dim;
		        if (disparo_e.life) {
		            if (dim_e.y < ta[1]) { /*Solo tratamos la bala si es menor al tamaño de la pantalla.*/
		                if (dim_e.dist(dim) < dim.w + dim_e.w && dim_e.dist(dim) < dim.h + dim_e.h) {
		                    nave.imparto_recuperate();
		                    /*Dejamos que la nave se vea atacada por unos 200ms.*/
		                    setTimeout(function () {
		                        nave.imparto_recuperate(false);
		                    }, 200);
		                    disparo_e.life = false;
		                    disparo_e.person.style.display = "none";
		                    break;
		                } else { /*No hubo imparto por lo que debemos seguir moviendo la bala hasta llegar donde está el jugador.*/
		                    disparo_e.person.style.top = (dim_e.y += 2.3) + "px";
		                }
		            } else {
		                disparo_e.life = false;
		                disparo_e.person.style.display = "none";
		                /*TODO Hacer: Investigar porque esto no funciona.*/
		            }
		        } else if (!Math.round(Math.random() * enemigo.length)) {
		            disparo_e.move_all(enemigo[e].dim.x, enemigo[e].dim.y);
		            disparo_e.person.style.display = "block";
		            enemigo[e].disparo.life = true;
		        }
		    } /*PERDER*/
		    if (nave.life < 0){
		    	game_over=true;
		    	if (confirm("          GAME OVER.\nQUIERES VOLVER A JUGAR.")){
		        	reiniciar();
		        	return true;
		        }
		    }
		    /*Si ya no hay enemigos entonces ganamos.*/
		    if (enemigo.length == 0) {
		        return ganar();
		    }
		    return false;
		}
		function game() {
		    if (game_over){
		    	console.log("end")
		        return;
		    }
		    move_all();
		    if (CO()){//Para evitar problemas con la llamada recursiva
		    	end_click();
		    	return true;
		    }
		    if (move_enemy) {
		        setTimeout(move_enemigo_abajo, second_enemigo_abajo);
		        move_enemy = false;
		    }
		    requesAnimation(game);
		}
		function reiniciar() { /*reinicia el juego*/
		    nave.recuperate(3);
		    /*Comenzamos por la ultima posicion del arrays porque a medida que el arrays baja debemos disminuir el contador.*/
		    for (let e = enemigo.length - 1, padre = get_element("almacenEn"); e >= 0; e--) { /*Eliminamos todos los enemigos.*/
		        enemigo[e].person.removeChild(enemigo[e].disparo.person);
		        padre.removeChild(enemigo[e].person);
		        /*Eliminamos la posicion e.*/
		        enemigo.splice(e, true);
		    }
		    get_element("fondo").innerHTML="";
		    get_element("almacenDis").innerHTML="";
		    get_element("vida").innerHTML="";
		    nave.disparo=[];
		    nave.life=4;
		    fondo=[];
		    init();
		}
	</script>
	</script>
</body>
</html>
<!--/*cursor:help
cursor:move
cursor:all-scroll
cursor:pointer
cursor:pointer
<div id="spacio"></div>
overflow:hidden;
auto
astroide:asteroide.bmp
nave_atacada.bmp
nv
*/-->
